# JAVA 数据结构与算法

#### 线性结构

1. 线性结构作为最常用的数据结构，其特点是**数据元素之间存在一对一**的线性关系
2. 线性结构有两种不同的存储结构，即顺序存储结构和链式存储结构
3. 顺序存储的线性表为顺序表，顺序表中的存续元素是连续的
4. 链式存储的线性表称为链表，链表中的**存储元素不一定是连续的**，元素节点中存放数据元素以及相邻元素的地址信息
5. 线性结构的常见的有： 数据，队列，链表和栈
6. 链表的优势是插入数据
7. 数组的优势是需要随机读取数据的时候，效率更高
8. 

#### 非线性结构

非线性结构包括： 二维数组，多维数组，广义表，**树结构，图结构**

### 稀疏数组sparse array

当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组

##### 稀疏数组的处理方法：

1. 记录数组一共有几行几列，有多少个不用的值
2. 把具有不同值得元素的行列及值记录再一个小规模的数组中，从而缩小程序的规模

### 队列

1. 队列首先是一个有序列表，可以用数组或者链表来实现
2. 遵循先入先出的原则： 即先存入队列的数据要先取出，后存入的要后取出

### 链表linked list

链表是有序的列表

1. 链表是以节点的方式来存储的
2. 每个节点包含data域 , next 域： 指向下一个节点
3. 链表的各个节点不一定是连续存放的
4. 链表分带头节点的链表和没有头节点的链表，根据实际需求来确定

单链表反转：

1. 先定义一个节点 reverseHead = new HeroNode();
2. 从头到尾遍历原来的链表，每遍历一个节点，就将其取出，并放到新链表reverseHead 的最前端
3. 原来的链表head.next= reverseHead.next

逆序打印单链表

1. 先将单链表反转再遍历，这样做会破坏原来单链表结构，不建议
2. 可以利用栈这个数据结构，将各个节点压入栈中，利用栈的先进后出的特点，实现逆序打印

##### 双向链表

1. 单向链表，查找的方向只能是一个方向，而双向链表可向前和向后查找
2.  单项链表不能自我删除，需要辅助节点，而双向链表可以自我删除

双向链表： 每个节点包含data域， next域 和pre 域， next 指向下一个节点，pre指向上一个节点



##### 单向环形链表

Josephus问题： 设编号为1,2...n 的n个人围坐一圈，约定编号为K （1<=k<=n）的人从1开始报数，数到m的那个人出列，

它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列

n=5，5个人

k=1 从第一个人开始报数

m=2, 数2下

构建一个单向环形链表思路：

1. 先创建第一个节点，让first指向该节点，并形成环形
2. 后面当我们每创建一个新的节点，就把该节点加入到已有的环形链表中

遍历环形链表：

1. 先让一个辅助指针curBoy指向first 节点
2. 然后通过一个while循环遍历该环形链表即可curBoy.next==first结束

### 栈 stack

1. 栈是一个先入后出  FILO  first in last out 的有序列表
2. 栈是限制线性表中元素的插入和删除，只能在线性表同一端进行的一种特殊线性表， 允许插入和删除的一端，为变化的一端，称为栈顶（Top）, 另一端为固定的一端，称为栈底（Bottom）
3. 根据栈的定义可知，最先放入栈中的元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除

入栈push ,  出栈 pop

##### 栈的应用场景

1. 子程序的调用： 在跳往子程序前， 会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中
2. 处理递归的调用： 和子程序的调用类似， 只是除了存储下以一个指令地址外，也将参数，区域变量等数据存入堆栈中
3. 表达式的转换【中缀表达式转后缀表达式】与求值
4. 二叉树遍历
5. 图形的深度优先（depth-first）搜索法



实现栈的思路分析：

1. 使用数组来模拟栈
2. 定义一个top来表示栈顶，初始化为-1
3. 入栈的操作，当有数据加入到栈时，top++; stack[top] = data;
4. 出栈的操作，int value = stack[top]; top--;return value;



##### 前缀，中缀，后缀表达式（逆波兰表达式）

前缀表达式（波兰表达式）, 从右向左扫描

1. 前缀表达式又称波兰式， 前缀表达式的运算符位于操作数之前
2. eg:(3+4)x5-6 对应的前缀表达式 ： - x + 3 4 5 6;

中缀表达式：(3+4)x5-6

后缀表达式（逆波兰表达式）： 从左至右扫描表达式，遇到数字，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算，（次顶元素和栈顶元素），并将结果入栈： 重复上述过程直到表达式最右端，最后运算得出的值为表达式

1. 后缀表达式又称逆波兰表达式，与前缀表达式相似，只是运算符位于操作数之后
2. eg: (3+4)x5-6  的后缀表达式就是 3 4 + 5  x 6 -

##### 中缀表达式转后缀表达式

1. 初始化两个栈， 运算符栈S1 和存储中间结果的栈S2
2. 从左到右扫描中缀表达式
3. 遇到操作数时，将其压入s2
4. 遇到运算符时，比较其与s1栈顶运算符的优先级

     	 1.  如果s1为空，或者栈顶运算符为左括号（ ， 则直接将此运算符入栈
              	 2.  否则，若优先级比栈顶运算符高，也将运算符压入s1
              	 3.  若s1栈顶的运算符弹出并压入到s2,再次转到（4.1）与s1中心的栈顶运算符相比较
5. 遇到括号时：

   1. 如果是左括号（ ， 则直接压入s1
   2. 如果是右括号）， 则依次弹出s1栈顶的运算符，并压入s2, 直到遇到左括号为止, 此时将这一对括号丢弃
6. 重复步骤2至5，直到表达式的最右边
7. 将s1中剩余的运算符依次弹出并压入s2
8. 依次弹出s2中的元素并输出，结果逆序即为中缀表达式对应的后缀表达式

### 递归

1.  当程序执行到一个方法时，就会开辟一个独立的空间（栈）
2. 每个空间的数据（局部变量）是独立的
3. 递归就是方法自己调用自己，每次调用传入不同的变量。递归有助于编程者解决复杂的问题

##### 应用场景: 解决什么问题

1. 各种数学问题： 8皇后问题，汉诺塔，阶乘问题，迷宫问题，球和篮子问题
2. 各种算法中也使用到递归，比如快排，归并排序，二分查找，分治算法等
3. 将用栈解决的问题---》 递归代码比较简洁

##### 递归需要遵守的规则

1. 执行一个方法时，就创建一个新的受保护的独立空间（栈空间）
2. 方法的局部变量是独立的，不会相互影响
3. 如果方法中使用的是引用类型的变量（如数组），就会共享该引用类型的数据
4. 递归必须向退出递归的条件逼近，否则就会无限递归，引起栈溢出 StackOverflowError
5. 当一个方法执行完毕，或者遇到return, 就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时， 该方法也就执行完毕。

### 排序 sort algorithm

排序的分类：

1. 内部排序，将需要处理的所有数据都加载到内部存储器进行排序
2. 外部排序，数据量过大， 无法全部加载到内存中，需要借助外部存储进行排序
3. 常见的排序算法分类
   - 内部排序:  插入排序（直接插入，希尔排序），选择排序（简单选择排序，堆排序），交换排序（冒泡排序，快速排序），归并排序，基数排序
   - 外部排序： 



##### 算法的时间复杂度

1. 事后统计法
   - 这种方法可行，但是，1，想要对设计的算法的运行性能进行评测，需要实际运行该程序，2，所得时间的统计量依赖于计算机的硬件，软件等环境因素，这种方式要在同一台计算机同一状态下运行，才能比较哪个算法更快
2. 事前估算法
   - 通过分析某个算法的时间复杂度来判断哪个算法更优

时间频度： 一个算法花费的时间与算法中语句执行的次数成正比例，哪个算法语句执行次数多，它花费的时间就多

一个算法中语句执行次数称为语句频度或者时间频度，记为T(n).



计算时间复杂度：

- 用常数1代替运行时间中的所有加法常数
- 修改后的运行次数函数中，只保留最高阶项
- 去除最高阶项的系数

常见的时间复杂度： 

1. 常数O(1)
2. 对数O（log₂n）
3. 线性O（n）
4. 线性对数O（nlog₂n）
5. 平方阶O（n²）
6. 立方阶O（n³）
7. K次方O（n^k）
8. 指数O（2ⁿ）
9. O（！n）

 **n:  数据规模**

说明： 常见的算法时间复杂度由小到大  O（1）<O（log2n） < O（n）<O（nlog2n） <O（n^2）<O（n^3））<O（n^k）< O（2^n）

随着问题规模n的不断增大，时间复杂度不断增大，算法的执行效率越低

尽可能避免使用指数阶算法

##### 空间复杂度：

1.  space complexity  算法的空间复杂度定义该算法耗费的存储空间，它也是问题规模n的函数
2. 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，有的算法需要占用的临时工作单元数与解决问题的规模n 有关，它随着n的增大而增大，而n较大时，将占用较多的存储单元，例如快速排序和归并排序
3. 在做算法分析的时候，主要讨论的是时间复杂度，从用户使用体验上，更看重程序执行的速度。一些缓存产品redis,memcache和算法（基数排序）本质就是用空间换时间

##### 一、冒泡排序 bubble sorting

 * 通过对待排序序列从前向后（从下标较小的元素开始）， 依次比较相邻的元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就像水底的气泡一样逐渐向上冒。

 * 排序规则： 

   1. 一共进行数组的大小-1次大的循环
   2. 每一趟排序的数量逐渐减小
   3. 如果我们发现在某趟排序中没有发生一次交换，可以提前结束冒泡排序（优化）

   

##### 二、选择排序  select sorting

-  第一次从arr[0]~arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]~arr[n-1]中选取最小值，与arr[1]交换，......第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列

- 排序规则：

  1. 选择排序一共有数组大小-1轮排序

  2. 每1轮排序，又是一个循环

  3. 先假定当前这个数是最小数

  4. 然后和后面的每个数进行比较，如果发现有比当前数更小的数，就重新确定最小数，并得到小标

  5. 当遍历到数组的最后时，就得到本轮最小数和下标

  6. 交换数据

     

##### 三、插入排序 insertion sorting

- 把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序列表的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。

##### 四、希尔排序 shell sort

- 希尔排序是donald shell 于1959年提出的一种排序算法，希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。
- 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序； 随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰好被分成一组，算法便终止。

##### 五、快速排序 quick sort

- 快速排序是对冒泡排序的一种改进，基本思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据编程有序序列

##### 六、归并排序 Merge sort

- 归并排序是利用归并的思想实现排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分（divide）成一些小的问题然后递归求解，而治（conquer）的阶段则将分的阶段得到的各答案“修补”在一起，即分而治之）。

##### 七、基数排序

- 基数排序（radix sort）属于 "分配式排序"  （distribution sort）,  又称 “桶子法” （bucket sort） 或者 bin sort,  它是通过键值得各个位的值，将要排序的元素分配至某些 “桶” 中， 达到排序的作用
- 基数排序法属于稳定性排序，基数排序法是效率高的稳定排序法
- 基数排序（radix sort）是桶排序的扩展，速度很快
- 基数排序是1887年赫尔曼*何乐礼发明的。 它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。
- 基本思想： 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列
- 基数排序是经典的空间换时间的方式，占用内存很大，当对海量数据排序时，容易造成OutOfMemoryError
- 有负数的数组，就不要使用基数排序来进行排序

##### 八、堆排序

- 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好平均时间复杂度均为O（nlogn）, 它也是不稳定排序

- 堆是具有以下性质的完全二叉树：每个结点的值度大于或等于其左右孩子结点的值，称为大顶堆，注意，没有要求结点的左孩子的值和右孩子的值的大小关系

- 每个结点的值都小于或者等于其左右孩子结点的值，称为小顶堆

- 大顶堆特点： arr[i]>=arr[2*i+1]&& arr[i]>=arr[2xi+2]  i 对应的第几个结点，i从0开始编号

- 小顶堆特点： arr[i]<=arr[2*i+1]&& arr[i]<=arr[2xi+2]  i 对应的第几个结点，i从0开始编号

- 一般升序采用大顶堆，降序采用小顶堆

- 时间复杂度O(nlogn)

  

### 查找算法

常用查找：

1. 顺序（线性）查找

2. 二分查找、折半查找， 必须对有序数组进行二分查找

3. 插值查找

   -  类似于二分查找，每次从自适应mid处开始查找
   - int mid = low+(high-low)*(key-arr[low])/(arr[hight]-arr[low] ) ； 插值索引
   - 对应代码： int mid = left+(right-left)* (findVal- arr[left])/(arr[right]-arr[left]);
   - 插值查找也要求数组时有序的
   - 对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找，速度较快
   - 关键字分布不均匀的情况，该方法不一定比折半查找好

   

4. 斐波那契查找（黄金分割法）

   - mid = low+F(k-1)-1
   - 必须在有序数组中查找



### 哈希表 Hash table

1. 哈希表（散列）是根据关键码值（Key value）而直接进行访问的数据结构，也就是说，它通过把关键码值映射到表中的一个位置来访问记录，以加快查找的速度。这个映射函数叫做<u>散列函数</u>，存放记录的数组叫做<u>散列表</u>
2. 可以用来做缓存

### 二叉树

1. 数组存储方式

   - 优点： 通过下标方式访问元素，速度快。对于有序数组，还可以使用二分查找提高检索速度。
   - 缺点： 如果要检索具体某个值，或者插入值（按一定顺序）会整体移动，效率低

2. 链式存储方式

   - 优点： 在一定程度上对数组存储方式有优化，如插入节点，只需要将插入节点链接到链表中即可，删除效率也很高
   - 缺点： 在进行检索时，效率较低，如需检索某个值，需要从头节点开始遍历

3. 树存储方式的分析

   - 能提高数据存储，读取的效率，比如利用二叉排序树（binary sort tree）, 既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度

   

#### 树的常用术语

1. 节点
2. 根节点 root
3. 父节点
4. 子节点
5. 叶子节点 ： 没有子节点的节点
6. 节点的权： 节点值
7. 路径： 从root节点找到该节点的路线
8. 层
9. 子树
10. 树的高度（最大层数）
11. 森林： 多棵子树构成森林

#### 二叉树

1. 树有很多种，每个节点最多只能有两个子节点，并且节点总数=2^n-1, n 为层数，则我们称为满二叉树。
2. 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边是连续，倒数第二层的叶子节点在右边是连续，我们就称为完全二叉树。

#### 二叉树遍历说明

- 前序遍历： 先输出父节点，再遍历左子树和右子树
- 中序遍历： 先遍历左子树，再输出父节点，再遍历右子树
- 后序遍历： 先遍历左子树，再遍历右子树，最后输出父节点

看输出父节点的顺序，就确定是前序，中序， 还是后序



##### 顺序存储二叉树

基本说明： 从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组。

顺序存储二叉树的特点：

1. 顺序二叉树通常只考虑完全二叉树
2. 第n个元素的左子节点为2*n+1
3. 第n个元素的右子节点为2*n+2
4. 第n个元素的父节点为(n-1)/2
5. n: 表示二叉树中的第几个元素（按0开始编号）

##### 线索化二叉树

1. n个节点的二叉链表中含有n+1个空指针域，公式【2n-(n-1) = n+1】, 利用二叉链表中的空指针域，存放指向节点在某种遍历次序下的前驱和后继节点的指针（这种附加的指针称为 “线索”）
2. 这种加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树（Threaded Binary Tree）。根据线索性质的不同，线索二叉树可分为前序线索二叉树，中序线索二叉树， 和后序线索二叉树三种
3. 一个节点的前一个节点，称为前驱节点
4. 一个节点的后一个节点，称为后继节点

##### 赫夫曼树

1. 给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度（wpl）达到最小，称这样的二叉树为最优二叉树，也称为赫夫曼树（HuffmanTree）
2. 赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近
3. 路径和路径长度： 在一棵树种，从一个结点往下可以达到的孩子和孙子结点之前的通路称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1
4. 结点的权，及带权路径长度： 若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权，结点的带权路径长度为：从根结点到该结点之前路径长度与该结点的权的乘积
5. 树的带权路径长度： 树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL（weighted path length）,  权值越大的结点离根结点越近的二叉树才是最优二叉树
6. WPL最小的就是赫夫曼树

###### 构建赫夫曼树的步骤

1. 从小到大进行排序，将每个数据，每个数据都是一个节点，每个节点可以看成一棵最简单的二叉树
2. 取出根节点权值最小的两棵二叉树
3. 组成一棵新的二叉树，该新的二叉树的根节点的权值是前面两棵二叉树根节点权值的和，
4. 再将这棵新的二叉树，以根节点的权值大小再次排序，
5. 不断重复1-2-3-4  直到数列中，所有的数据都被处理，就得到一棵赫夫曼树

##### 赫夫曼编码

1. 赫夫曼编码是一种编码方式，属于程序算法

2. 赫夫曼编码是赫夫曼树在电讯通信中的经典的应用之一

3. 赫夫曼编码广泛地用于数据文件压缩，其压缩率通常在20%-90%之间

4. 赫夫曼码是可变字长编码（VLC）的一种，huffman于1952年提出的一种编码方法称为最佳编码

5. 赫夫曼编码是无损压缩编码

6. 如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化，如视频，ppt等

7. 赫夫曼编码是按字节来处理的，因此可以处理所有的文件（二进制文件，文本文件）

8. 如果一个文件的内容，重复的数据不多，压缩效果也不会很明显

   
   
   

#### 二叉排序树

1. 树存储方式的分析 ： 能提高数据存储，读取的效率，比如利用 二叉排序树（Binary Sort Tree）, 既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改

#### 平衡二叉树

1. 平衡二叉树也叫平衡二叉搜索树（self-balancing binary search tree）, 又被称为AVL树，可以保证查询效率较高
2. 具有以下特点： 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树，平衡二叉树的常用实现方法有红黑树，AVL，替罪羊树，Treap, 伸展树等

#### 二叉树与B树

1. 二叉树需要加载到内存，如果二叉树的节点少，没什么问题，如果节点多就会存在以下问题：
   1. 问题1： 在构建二叉树时，需要多次进行I/O操作（海量数据存在数据库或文件中），节点海量，构建二叉树时速度有影响
   2. 问题2： 节点海量，也会造成二叉树的高度很高，会降低操作速度
2. 多叉树 （multiway tree）2-3树，2-3-4树  对二叉树进行优化

##### B树

1. 通过重新组织节点，降低树的高度，并且减少I/O读写次数来提升效率
2. 文件系统及数据库系统的设计者利用磁盘预读原理，将一个节点的大小设为等于一个页（页的大小通常为4K），这样每个节点只需要一次I/O就可以完全载入
3. 将树的度M设置为1024， 在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素，B树广泛用于文件存储系统以及数据库系统中

##### 2-3树

1. 2-3树的所有叶子节点都在同一层 （只要是B树都满足这个条件）
2. 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点
3. 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点
4. 2-3树是由二节点和三节点构成的树

##### B树 =>  B-tree  B树， balanced tree

1. B 树的阶： 节点最多的子节点个数，如2-3树的阶是3,2-3-4树的阶是4
2. B树的搜索，从根节点开始，对节点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子节点，重复搜索，直到所有对应儿子指针为空，或者已经是叶子结点
3. 关键字集合分布在整棵树种，即叶子结点和非叶子结点都存放数据
4. 搜索可能在非叶子结点就结束了
5. 其搜索性能等价于在关键字全集内做一次二分查找

##### B+ 树  =>  B树的变体，也是一种多路搜索树

1. B+树的搜索与B树叶基本相同，区别是B+ 树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键词全集做一次二分查找
2. 所有关键字都出现在叶子结点的链表中（即数据只能在叶子结点， 也叫稠密索引），且链表中的关键字（数据）恰好是有序的
3. 不可能在非叶子结点命中
4. 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层
5. 更适合文件索引系统
6. B树和B+树各有自己的应用场景，不能说B+ 树完全比B树好

##### B* 树 =>  B*树是B+树的变体，在B+树的非根和非叶子结点增加了指向兄弟结点的指针

1. B*树定义了非叶子结点关键字个数至少为（2/3）\*M, 即块的最低使用率为2/3, 而B+树的块的最低使用率为1/2
2. B*树分配新结点的概率比B+树要低，空间使用率更高



#### 图的基本介绍和存储形式

1. 需要多对多关系时就需要用到图
2. 树只能有一个直接前驱也就是父节点
3. 线性表局限于一个直接前驱和一个直接后继关系

图是一种数据结构，其中节点可以具有零个或多个相邻元素，两个节点之间的连接称为边，节点也可以称为顶点

##### 图的常用概念

1. 顶点 vertex
2. 边 edge
3.  路径
4. 无向图
5. 有向图
6. 带权图



##### 图的表示方式

1. 图的表示方式有两种： 二维数组表示（邻接矩阵）； 链表表示（邻接表）
2. 邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，，矩阵是row 和col表示1...n个点
3. 邻接表
   1. 邻接矩阵需要为每个顶点都分配n个边的空间，其实很多边都是不存在的，会造成一定的空间浪费
   2. 邻接表的实现只关心存在的边，不关心不存在的边，因此没有空间浪费，邻接表由数组+链表组成

##### 图的深度优先 Depth First Search

1. 深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问

##### 图的广度优先遍历  Broad First search

1. 图的广度优先搜索类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点
2. 





































