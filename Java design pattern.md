# Java Design Pattern

设计原则的核心思想：

1. 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。
2. 针对接口编程，而不是针对实现编程
3. 为了交互对象之间的松耦合设计而努力

#### FAQ

1. 请使用UML类图画出原型模式核心角色

2. 原型设计模式的深拷贝和浅拷贝是什么，并写出深拷贝的两种方式的源码（重写clone方法实现深拷贝，使用序列化来实现深拷贝）

3. 在spring框架中哪里使用到原型模式，并对源码进行分析

   beans.xml

   ```java
   <bean id="id" class="com.abc.spring.bean.Monster" scope="prototype"/>
   ```

4. 在Spring中原型bean的创建，就是原型模式的应用
5. 在实际项目开发中，在哪里使用到ocp原则  =》  factory pattern
6. 介绍解释器设计模式是什么？
7. 画出解释器设计模式UML类图，分析设计模式中各个角色是什么？
8. 请说明Spring框架中，哪里使用到了解释器设计模式，并做到源码级别分析
   - Spring框架中SpelExpressionParser就使用到了解释器模式
9. 单例设计模式一共有几种实现方式？ 请分别用代码实现，并说明各个实现方式的优点和缺点？
   - 饿汉式  两种
   - 懒汉式  三种
   - 双重检查 多线程  doublecheck
   - 静态内部类
   - 枚举
10. 实际项目中使用过什么设计模式，怎么使用的，解决了什么问题
11. 设计模式在软件中哪里 ？ 面向对象OO => 功能模块【设计模式+算法（数据结构）】=>  框架【使用多种设计模式】=>  架构【服务器集群】
12. 

##### Erich Gamma 引入

扩展性，稳定性，可读性，可维护性，规范性高，重用性，可靠性

使程序呈现高内聚，低耦合



## 七大设计原则

#### 1. 单一职责原则

- 对类来说，一个类应该只负责一项职责

- 提高类的可读性，可维护性
- 降低变更引起的风险
- 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；
- 只有类中方法数量足够少，可以在方法级别保持单一原则



#### 2. 接口隔离原则 interface segragation principle

- 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小接口上

#### 3. 依赖倒转原则（Dependence Inversion Principle）

1. 高层模块不应该依赖低层模块，二者都应该依赖其抽象
2. 抽象不应该依赖细节，细节应该依赖抽象
3. 依赖倒转（倒置）的中心思想是面向接口编程
4. 依赖倒转原则是基于这样的设计理念，相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础搭建的架构要稳定的多。在java中，抽象是指接口或者抽象类，细节就是具体的实现类
5. 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成

##### 依赖关系的传递方式：

1. 通过接口传递实现依赖
2. 通过构造方法实现依赖传递
3. 通过setter方法传递

##### 依赖倒转原则的注意事项：

1. 低层模块尽量都要有抽象类或者接口，或者两者都有，程序稳定性更好
2. 变量的声明类型尽量是抽象类或者接口，这样我们的变量引用和实际对象间就存在缓存层，利于程序扩展和优化
3. 继承时遵循里氏替换原则

#### 4. 里氏替换原则（Liskov Substitution Principle）

1. 如果对每个类型为T1对象o1， 都有类型为T2的对象o2, 使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须透明地使用其子类的对象。
2. 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法
3. 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。

#### 5. 开闭原则 （Open Closed Principle）OCP

1. 开闭原则是编程中最基础，最重要的设计原则
2. 一个软件实体如类，模块和函数应该对扩展开放（对提供方）， 对修改关闭（对使用方），用抽象构建框架，用实现扩展细节
3. 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化
4. 编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则

#### 6. 迪米特法则 （Demeter Principle）

1. 一个对象应该对其他对象保持最少的了解
2. 类与类关系越密切，耦合度越大
3. 迪米特法则又叫最少知道原则，即一个类对自己依赖的类知道的越少越好，对外除了提供public方法外，不对外泄露任何信息
4. 迪米特法则还有一个更简单的定义： 只与直接的朋友通信
5. 直接的朋友： 每个对象都会与其他对象有耦合关系只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等，其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友，也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。

#### 7. 合成复用原则

- 尽量使用合成/聚合的方式，而不是使用继承

#### 8. UML类图

unified modeling language

rational rose

-  依赖关系dependency： 只要在类中用到了对方，那么他们之间就存在依赖关系
  - 类中用到对方
  - 如果是类的成员属性
  - 如果是方法的返回类型
  - 是方法的接收类型
  - 方法中使用到
- 泛化generalization： 实际是继承关系，是依赖关系的特例
  - 泛化关系就是继承关系
- 实现关系implementation: 实现关系实际上就是A类实现B类，也是依赖关系的特例
- 关联关系association : 关联关系实际上就是类与类之间的联系，他是依赖关系的特例
  - 关系具有导航性： 即双向关系或单向关系
  - 关系具有多重性： 如1表一有且有一个，0..表示0个或多个
- 聚合关系aggregation:  聚合关系表示的是整体和部分的关系，整体和部分都可以分开。聚合关系时关联关系的特例，具有关联的导航性和多重性。
- 组合关系Composition: 如果整体和部分不能分开，就升级为组合关系
  - 如果一个类定义了对另一个类的级联删除，那他们就是组合关系

#### 设计模式

设计模式的本质是提高软件的维护性，通用性和扩展性，并降低软件的复杂性。

##### 创建型模式：

1. 单例模式

   - 采取一定方法保证整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）

   - 如Hibernate的SessionFactory，它充当数据存储源的代理，并负责创建Session对象。SessionFactory并不是轻量级的，一般情况下，一个项目通常只需要一个SessionFactory，就会用到单例模式。

   - 想实例化一个单例类，必须记住使用相应的获取对象的方法，而不是使用new

   - 单例模式使用场景： 需要频繁的进行创建和销毁的对象，创建对象时耗时过多或耗费资源过多（即重量级对象），但又经常用到的对象，工具类对象，频繁访问数据库或文件的对象(如：数据源，session工厂等)

   - 单例的八种方式

     1. 饿汉式（静态常量）

        ```java
        class SingleTon{
            //1.private consturctor, disable new instance
        	private SingleTon(){}
            //2.create instance
            private final static SingleTon instance = new SingleTon();
            //3.static factory method
            public static SingleTOn getInstance(){
                return instance;
            }
        }
        //优点：写法简单，在类装载时就完成实例化，避免了线程同步问题。
        //缺点：在类装载时就完成实例化，没有达到Lazy Loading的效果。如果从未使用过这个实例，则会造成内存浪费。
        //这种方式基于classloader机制避免了多线程同步问题
        //结论： 可能会造成内存浪费，确定会用到该实例时使用
        ```

     2. 饿汉式（静态代码块）

        ```java
        class SingleTon{
            //1.init instance
            private static SingleTon instance;
            //2.create instance in static block
            static{
                instance = new SingleTon();
            }
         	//3.private consturctor, disable new instance
        	private SingleTon(){}
            //4.static factory method
            public static SingleTOn getInstance(){
                return instance;
            }
        }
        //这种方式和第一种类似，只是将类的实例化放到了静态代码块中，也是在类装载时初始化实例，优缺点与第一种相同。
        ```

     3. 懒汉式（线程不安全）

        ```java
        class SingleTon{
            //1.init instance
            private static SingleTon singleton;
            //2.private consturctor, disable new instance
        	private SingleTon(){}
         
            //3.static factory method, create instance when invocate getInstance
            public static SingleTOn getInstance(){
                if(singleton==null){
                    singleton = new SingleTon()； 
                }
                return singleton;
            }
        }
        //能起到Lazy Loading的效果，但只能单线程使用
        //如在多线程中，一个线程进入if语句，还未来得及执行，另一个线程也通过了该判断语句，这时会产生多个实例，在实际多线程环境下不可以使用这种方式
        //结论: 在实际开发中不要使用
        ```

        

     4. 懒汉式（线程安全，同步方法）

        ```java
        class SingleTon{
            //1.init instance
            private static SingleTon singleton;
            //2.private consturctor, disable new instance
        	private SingleTon(){}
         
            //3.static factory method, create instance when invocate getInstance
            //add sychronized
            public static sychronized SingleTOn getInstance(){
                if(singleton==null){
                    singleton = new SingleTon()； 
                }
                return singleton;
            }
        }
        //解决了线程不安全问题，但是效率太低，每个线程想获取实例的时候，执行getInstance方法都要进行同步，而这个方法其实只执行一次就够了
        //结论: 在实际开发中不推荐使用
        ```

     5. 懒汉式（线程安全，同步代码块）

        ```java
        class SingleTon{
            //1.init instance
            private static SingleTon singleton;
           
            //2.private consturctor, disable new instance
        	private SingleTon(){}
         
            //3.static factory method, create instance when invocate getInstance
            //add sychronized
            public static SingleTOn getInstance(){
                if(singleton==null){
                    sychronized(Singleton.class){
                         singleton = new SingleTon()； 
                    }
                }
                return singleton;
            }
        }
        //未解决了线程安全问题
        //结论: 在实际开发中不能使用
        ```

     6. 双重检查

        ```java
        class SingleTon{
            //1.init instance
            //volatile 可以及时更新到主程，轻量的sychronized
            private static volatile SingleTon singleton;
            //2.private consturctor, disable new instance
        	private SingleTon(){}
         
            //3.static factory method, create instance when invocate getInstance
            public static sychronized SingleTOn getInstance(){
                if(singleton==null){
                     sychronized(Singleton.class){
                         if(singleton==null){
                             singleton = new SingleTon()； 
                         }
                    } 
                }
                return singleton;
            }
        }
        //能解决线程安全问题，也能解决效率问题
        //结论: 在实际开发中推荐使用
        ```

     7. 静态内部类

        ```java
        class SingleTon{
            //1.private consturctor, disable new instance
        	private SingleTon(){}
            //2.init instance
            private static class SingletonInstance{
                //特点：外部类进行类装载时静态内部类不会装载
                //用到内部类时静态内部类才装载，只装载一次，线程安全
                private static final Singleton INSTANCE = new Singleton();
            }
            //3.static factory method，直接返回成员类
            public static sychronized SingleTOn getInstance(){
                return SingletonInstance.INSTANCE;
            }
        }
        //采用了类装载的机制来保证初始化时只有一个线程
        //类的静态属性只会在第一次加载类的时候初始化，在类初始化时，别的线程无法进入，JVM帮我们保证了线程安全
        //能起到Lazy Loading的效果，也能保证线程安全，效率高
        //结论: 在实际开发中推荐使用
        ```

     8. 枚举

        ```java
        enum SingleTon{
            INSTANCE;
        	public void method(){}
        }
        //借助JDK1.5中添加的枚举来实现单例模式，不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。
        //能起到Lazy Loading的效果，也能保证线程安全，效率高
        //结论: 在实际开发中推荐使用
        ```

2. 抽象工厂模式

   - 抽象工厂模式：定义一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类。
   - 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合
   - 从设计层面看，抽象工厂模式就是对简单工厂模式的改进（或称为进一步抽象）
   - 将工厂抽象成两层，AbsFactory(抽象工厂)和具体实现的工厂子类，可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。

3. 工厂模式

   - 设计模式的依赖抽象原则
     - 创建对象实例时，不要直接new类，而是把这个new类的动作放在一个工厂方法中，并返回。变量不要直接持有具体类的引用。
     - 不要让类继承具体类，而是继承抽象类或者实现interface接口
     - 不要覆盖基类中已经实现的方法。

   - 简单工厂模式： 
     - 简单工程模式是属于创建型模式，是工厂模式的一种，简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。
     - 简单工厂模式： 定义一个创建对象的类，由这个类来封装实例化对象的行为
     - 在软件开发中，我们会用到大量的创建某种，某类，或者某批对象时，就会使用到工厂模式
     - 简单工厂模式又叫静态工厂模式
   - 工厂方法模式
     - 将对象实例化功能抽象成抽象方法，在子类中具体实现。
     - 定义一个创建对象的抽象方法，由子类决定要实例化的类，将对象实例化推迟到子类中实现。

4. 原型模式

   - Spring中的原型bean创建，就是用的原型模式

   - 原型模式prototype是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。
   - 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象， 无需知道如何创建的细节
   - 工作原理： 通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 对象.clone()
   - 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率
   - 不用重新初始化对象，而是动态的获取对象运行时的状态
   - 如果原始对象发送变化（增加或者减少属性），其他克隆对象也会发生相应的变化，无需修改代码
   - 实现深克隆可能需要比较复杂的代码
   - 缺点： 需要为每个类配备一个克隆方法，这对全新的类来说不难，但是对已有的类进行改造需要修改其源码，违背OCP原则。

   ###### 浅拷贝：shallow copy

   - 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。
   - 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组，某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。
   - 浅拷贝使用默认的clone方法来实现

   ###### 深拷贝：deep copy

5. 建造者模式builder pattern

   - 是一种对象构建模式，它可以将负责对象的构建过程抽象出来（抽象类别）  ，使这个抽象过程的不同实现方法可以构造出不同的表现（属性）对象。
   - 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的构建细节
   - 建造者模式的四个角色：
     1. Product 产品对象
     2. Builder 抽象建造者，创建一个product对象的各个部件指定的接口/抽象类
     3. ConcreteBuilder 具体建造者，实现接口，构建和装配的各个部件
     4. Director 指挥者，构建一个使用Builder接口的对象，它主要是用于创建复杂的对象。主要有两个作用：一是隔离用户与对象的生产过程，二是： 负责控制产品对象的生产过程。
   - JDK应用： StringBuilder

##### 结构性模式

1. 适配器模式 Adapter Pattern

   - 将某个类的接口转换成客户端期望的另一个接口表示，主要的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。 其别名为包装器Wrapper
   - 类适配器 :  使用继承实现
   - 对象适配器 :  根据合成复用原则，使用组合替代继承，所以解决了类适配器必须继承的局限性问题，也不再要求dst必须是接口
     - 使用成本更低，更灵活
   - 接口适配器
     - Default Adapter Pattern, 缺省适配器模式
     - 当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法）。那么该抽象类的子类可有选择的覆盖父类的某些方法来实现需求
     - 适用于一个接口不想使用其所有方法的情况
   - SpringMVC的handleAdapter
2. 桥接模式 Bridge
   - 将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。
   - Bridge模式基于类的最小设计原则，通过使用封装，聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象（Abstraction）与行为实现Implementation分离开来，从而可以保持各个部分的独立性以及应对他们的功能扩展。
   - JDBC的Driver接口，如果从桥接模式来看，Driver就是一个接口，下面可以有MySQL的driver,可以有 Oracle的driver
3. 装饰者模式Decorator
   - 装饰者模式： 动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则（ocp）。
   - 主体Component + 具体的主体ConcreteComponent + 装饰者Decorator, 如concreteComponent类很多，可以设计一个缓冲层，将共有的部分提取出来，抽象成一个类。
   - JDK 中的使用： Java的IO， FilterInputStream就是一个装饰者
4. 组合模式Composite Pattern
   - 又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“整体+部分” 的层次关系。
   - 组合模式依据树形结构来组合对象，用来表示部分以及整体层次
   - 这种类型的设计模式属于结构型模式
   - 组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户一致的方式处理个别对象以及组合对象。
   - 组合模式结构：
     - Component: 这是组合中对象声明的接口，在适当情况下，实现所有类共有的接口默认行为，用于访问和管理Component子部件，Component抽象类或者接口
     - Leaf： 在组合中表示叶子节点，没有子节点
     - Composite： 非叶子节点，用于存储子部件，在Component接口中实现子部件的相关操作
   - 解决的问题： 当我们要处理的对象可以生成一棵树形结构时，我们要对树上的节点和叶子进行操作时，它能够提供一致的方式，而不用考虑它的节点还是叶子。
   - JDK- HashMap就使用了组合模式
5. 外观模式Facade  
   - 外观模式也叫过程模式，外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得子系统更加容易使用。
   - 外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需要跟这个接口发生调用，而无需关心这个子系统的内部细节。
   - 主要解决多个复杂接口带来的使用困难，起到简化用户操作的作用。
   - MyBatis中configuration去创建MetaObject对象用到了外观模式
6. 享元模式Flyweight Pattern 
   - 享元模式也叫蝇量模式： 运用共享技术有效地支持大量细粒度的对象。
   - 常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个
   - 享元模式能够解决重复对象的内存浪费问题，当系统中有大量相似对象，需要缓冲时，不需要总是创建对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率。
   - 享元模式经典的应用场景就是池技术，String常量池，数据库连接池，缓冲池等等都是亨元模式的应用，亨元模式是池技术的重要实现方式。
   - 实现：
     1. FlyWeight 是抽象的享元角色，他是产品的抽象类，同时定义出对象的外部状态和内部状态的接口和实现
     2. ContreteFlyWeight 是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务
     3. UnsharedConcreteFlyWeight 是不可共享的角色，一般不会出现在享元工厂
     4. FlyWeightFactory  享元工厂类，用于构建一个池容器（集合）， 同时提供从池中获取对象方法
7. 代理模式Proxy
   - 代理模式： 为一个对象提供一个替身，以控制对这个对象的访问，即通过代理对象访问目标对象。这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。
   - 被代理的对象可以是远程对象，创建开销大的对象或需要安全控制的对象。
   - 代理模式有不同的形式，主要有静态代理，动态代理（JDK代理，接口代理）和Cglib代理（可以在内存中动态创建对象，而不需要实现接口，他是属于动态代理范畴）
   - 静态代理在使用时，需要定义接口或者父类，被代理对象（即目标对象）与代理对象一起实现相同的接口或者是继承相同父类
   - 动态代理对象：
     1. 不需要实现接口，但是目标对象要实现接口，否则不能用动态代理
     2. 代理对象的生产，是利用JDK的API，动态的在内存中构建代理对象
     3. 动态代理也叫： JDK代理，接口代理
   - Cglib代理：
     1. 静态代理和JDK代理都要求目标对象实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候可使用目标对象子类来实现代理，这就是Cglib代理
     2. Cglib代理也叫作子类代理，它是内存中构建一个子类对象从而实现对目标对象功能扩展，有些书上也将Cglib代理归属到动态代理。
     3. Cglib是一个强大的高性能的代码生成包，它可以在运行期扩展java类，实现java接口，它广泛的被许多AOP的框架，例如Spring AOP， 实现方法拦截
     4. 在AOP编程中如何选择代理模式：
        - 目标对象需要实现接口，用JDK代理
        - 目标对象不需要实现接口，用Cglib代理
     5. Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类
   - 几种变体：
     - 防火墙代理： 内网通过代理穿透防火墙，实现对公网访问
     - 缓存代理： 当请求图片等资源时，先到缓存代理取，如取不到资源再到公网或者数据库去取，然后缓存
     - 远程代理： 远程对象的本地代表，通过它可以把远程对象当本地对象来调用，远程代理通过网络和真正的远程对象沟通信息。
     - 同步代理： 主要使用在多线程编程中，完成多线程间同步工作。

##### 行为型模式

1. 模板方法模式 Template Method Pattern
   - 又叫模板模式（Template Pattern） ，在一个抽象公开定义了执行它的方法的模板，它的子类可以按需要重写方法实现，但是调用将以抽象类中定义的方式进行
   - 简单说，模板方法模式定义了一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重新定义该算法的某些特定步骤
   - 在Spring框架IOC 容器初始化时运用到模板方法： ConfigurableApplicationContext中用到了模板方法
   - 基本思想： 算法只存在一个地方，也就是父类中，容易修改
   - 实现最大化代码复用
   - 既统一了算法，也提供了很大的灵活性
   - 模板方法： 当要完成的某个过程，该过程要执行一系列步骤，这个步骤基本相同，个别步骤实现时不同，通常考虑用模板方法来处理
2. 命令模式 Command Pattern
   - 在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个
   - 我们只需要在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计
   - 命令模式使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦。
   - 在命令模式中，会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求，同时命令模式也支持可撤销的操作
   - 在Spring框架JDBC Template使用命令模式
3. 访问者模式 Visitor Pattern
   - 封装一些作用于某种数据结构的各元素的操作，它可以在不改变数据结构的前提下，定义作用于这些元素的新操作
   - 主要将数据结构与数据操作分离，解决数据结构和操作耦合性问题
   - 访问者模式的基本工作原理是： 在被访问的类里面加一个对外提供接待访问者的接口
   - 访问者模式主要应用场景： 需要对一个对象结构中的对象进行很多不同操作，同时需要避免让这些操作“污染”这些对象的类，可以选用访问者模式
   - 优点： 
     - 访问者模式符合单一职责原则，让程序具有优秀的扩展性，灵活性非常高
     - 访问者模式可以对功能进行统一，可以做报表，UI，拦截器与过滤器，适用于数据结构相对稳定的系统
   - 缺点：
     - 具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则不建议的，这样造成具体元素的变更比较困难
     - 违背了依赖倒转原则，访问者依赖的是具体元素，而不是抽象元素
     - 如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问者模式就是比较合适的。
4. 迭代器模式 Iterator Pattern 
   - 如果我们的集合元素是用不同的方式实现的，有数组，还有java的集合类，或者还有其他方式，当客户端要遍历这些集合元素的时候就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决
   - 迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示，即: 不暴露其内部的结构
   - JDK中的ArrayList用到了迭代器模式
5. 观察者模式
   - 对象之间多对一依赖的一种设计方案，被依赖的对象为subject, 依赖的对象为observer, subject通知observer变化。
   - JDK中Observable类中使用到了观察者模式
6. 中介者模式  Mediator Pattern
   - 用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互
   - 中介者模式属于行为行为模式，易于维护
   - 如MVC模式中的中介者，Controller在前后端交互中起到中介者,  可以调用多个Model
   - 多个类相互耦合，会形成网状结构，使用中介者模式将网状结构分离为星型结构，进行解耦
   - 减少类之间的依赖，降低耦合，符合迪米特发着
   - 中介者承担了较多责任，一旦中介者出现问题，整个系统就会受到影响
   - 如果设计不当，中介者对象本身变得过于复杂。
7. 备忘录模式  Memento Pattern
   - 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象回复到原先保存的状态
   - 备忘录对象主要用来记录一个对象的某种状态，或者某些数据，当要做回退时，可以从备忘录对象里获取原来的数据进行恢复操作
   - 给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态
   - 实现了信息的封装，使得用户不需要关心状态的保存细节
   - 但如果类的成员过多，势必会占用比较大的资源，而且每次保存都会消耗一定的内存，需要特别注意
   - 适用场景： 后悔药，游戏存档，回撤，后退，数据库事务管理
   - 为了节约内存，备忘录模式可以和原型模式配合使用
8. 解释器模式（Interpreter模式）
9. 状态模式
10. 策略模式
11. 职责链模式（责任链模式）

