# Java Design Pattern

#### FAQ

1. 请使用UML类图画出原型模式核心角色

2. 原型设计模式的深拷贝和浅拷贝是什么，并写出深拷贝的两种方式的源码（重写clone方法实现深拷贝，使用序列化来实现深拷贝）

3. 在spring框架中哪里使用到原型模式，并对源码进行分析

   beans.xml

   ```java
   <bean id="id" class="com.abc.spring.bean.Monster" scope="prototype"/>
   ```

4. 在Spring中原型bean的创建，就是原型模式的应用
5. 在实际项目开发中，在哪里使用到ocp原则  =》  factory pattern
6. 介绍解释器设计模式是什么？
7. 画出解释器设计模式UML类图，分析设计模式中各个角色是什么？
8. 请说明Spring框架中，哪里使用到了解释器设计模式，并做到源码级别分析
   - Spring框架中SpelExpressionParser就使用到了解释器模式
9. 单例设计模式一共有几种实现方式？ 请分别用代码实现，并说明各个实现方式的优点和缺点？
   - 饿汉式  两种
   - 懒汉式  三种
   - 双重检查 多线程  doublecheck
   - 静态内部类
   - 枚举
10. 实际项目中使用过什么设计模式，怎么使用的，解决了什么问题
11. 设计模式在软件中哪里 ？ 面向对象OO => 功能模块【设计模式+算法（数据结构）】=>  框架【使用多种设计模式】=>  架构【服务器集群】
12. 

##### Erich Gamma 引入

扩展性，稳定性，可读性，可维护性，规范性高，重用性，可靠性

使程序呈现高内聚，低耦合



## 七大设计原则

#### 1. 单一职责原则

- 对类来说，一个类应该只负责一项职责

- 提高类的可读性，可维护性
- 降低变更引起的风险
- 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；
- 只有类中方法数量足够少，可以在方法级别保持单一原则



#### 2. 接口隔离原则 interface segragation principle

- 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小接口上

#### 3. 依赖倒转原则（Dependence Inversion Principle）

1. 高层模块不应该依赖低层模块，二者都应该依赖其抽象
2. 抽象不应该依赖细节，细节应该依赖抽象
3. 依赖倒转（倒置）的中心思想是面向接口编程
4. 依赖倒转原则是基于这样的设计理念，相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础搭建的架构要稳定的多。在java中，抽象是指接口或者抽象类，细节就是具体的实现类
5. 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成

##### 依赖关系的传递方式：

1. 通过接口传递实现依赖
2. 通过构造方法实现依赖传递
3. 通过setter方法传递

##### 依赖倒转原则的注意事项：

1. 低层模块尽量都要有抽象类或者接口，或者两者都有，程序稳定性更好
2. 变量的声明类型尽量是抽象类或者接口，这样我们的变量引用和实际对象间就存在缓存层，利于程序扩展和优化
3. 继承时遵循里氏替换原则

#### 4. 里氏替换原则（Liskov Substitution Principle）

1. 如果对每个类型为T1对象o1， 都有类型为T2的对象o2, 使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须透明地使用其子类的对象。
2. 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法
3. 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。

#### 5. 开闭原则 （Open Closed Principle）OCP

1. 开闭原则是编程中最基础，最重要的设计原则
2. 一个软件实体如类，模块和函数应该对扩展开放（对提供方）， 对修改关闭（对使用方），用抽象构建框架，用实现扩展细节
3. 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化
4. 编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则

#### 6. 迪米特法则 （Demeter Principle）

1. 一个对象应该对其他对象保持最少的了解
2. 类与类关系越密切，耦合度越大
3. 迪米特法则又叫最少知道原则，即一个类对自己依赖的类知道的越少越好，对外除了提供public方法外，不对外泄露任何信息
4. 迪米特法则还有一个更简单的定义： 只与直接的朋友通信
5. 直接的朋友： 每个对象都会与其他对象有耦合关系只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等，其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友，也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。

#### 7. 合成复用原则



#### 设计模式分类

1. 单例模式
2. 简单工程模式
3. 工厂方法模式
4. 抽象工厂模式
5. 原型模式
6. 建造者模式
7. 适配器模式
   - 类适配器
   - 对象适配器
   - 接口适配器
8. 桥接模式
9. 装饰者模式
10. 组合模式
11. 外观模式
12. 亨元模式
13. 代理模式
14. 模板模式
15. 命令模式
16. 访问者模式
17. 迭代器模式
18. 观察者模式
19. 中介者模式
20. 备忘录模式
21. 解释器模式
22. 状态模式
23. 策略模式
24. 职责链模式

